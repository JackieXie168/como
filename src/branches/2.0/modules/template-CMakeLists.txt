PROJECT(MODULE C)

# Builder has to pass these variables
MESSAGE("Building CoMo module ${MODULE} (${MODULE_SOURCE_DIR})")

#
# enable mono support if present
#
SET(MONO_FOUND @MONO_FOUND@)
IF(MONO_FOUND)
  SET(MONO_CFLAGS  "@MONO_CFLAGS@")
  SET(MONO_MCS     "@MONO_MCS@")

  ADD_DEFINITIONS(${MONO_CFLAGS})
ENDIF(MONO_FOUND)

#
# check for structmagic
#
SET(STRUCTMAGIC "@ABS_INST_LIBDIR@/structmagic")
IF(NOT EXISTS ${STRUCTMAGIC})
  MESSAGE("can't find structmagic at \"${STRUCTMAGIC}\"")
ENDIF(NOT EXISTS ${STRUCTMAGIC})

ADD_DEFINITIONS("-Dcomo_config=\"\" -Dcomo_tuple=\"\" -Dcomo_record=\"\"")

#
# Add the CoMo includes
#
INCLUDE_DIRECTORIES("@ABS_INST_INCDIR@")

#
# Create appropriate targets for each module
#
MESSAGE(STATUS "Inferring module dependencies")

SET(MODULE_DATADEF        ${MODULE_SOURCE_DIR}/data.h)
SET(MODULE_INIT           ${MODULE_SOURCE_DIR}/init.c)
SET(MODULE_CAPTURE        ${MODULE_SOURCE_DIR}/capture.c)
SET(MODULE_EXPORT_C       ${MODULE_SOURCE_DIR}/export.c)
SET(MODULE_EXPORT_CSHARP  ${MODULE_SOURCE_DIR}/export.cs)
SET(MODULE_QUERY_C        ${MODULE_SOURCE_DIR}/query.c)
SET(MODULE_QUERY_CSHARP   ${MODULE_SOURCE_DIR}/query.cs)

SET(MODULE_DLL            ${MODULE_BINARY_DIR}/${MODULE}.dll)
SET(MODULE_SO             ${MODULE_BINARY_DIR}/${MODULE}.so)

# files generated by structmagic
SET(MODULE_SERIAL         ${MODULE_BINARY_DIR}/gen-serial.c)
SET(MODULE_CSGLUE         ${MODULE_BINARY_DIR}/gen-csglue.c)
SET(MODULE_TYPENAMES      ${MODULE_BINARY_DIR}/gen-typenames.c)
SET(MODULE_CSCLASS        ${MODULE_BINARY_DIR}/gen-class.cs)

SET(MODULE_LANGDEF        ${MODULE_BINARY_DIR}/langdef.c)

# specific cflags to compile the module
SET(MODULE_CFLAGS "-I${MODULE_SOURCE_DIR}")

# check for required files

MACRO(CHECK_EXISTENCE _file _what)
  IF(NOT EXISTS ${_file})
    MESSAGE(FATAL_ERROR "module ${MODULE} is missing ${_file}")
  ENDIF(NOT EXISTS ${_file})
MESSAGE("\t${_what}: file ${_file}")
ENDMACRO(CHECK_EXISTENCE)

CHECK_EXISTENCE(${MODULE_DATADEF} "datadef")
CHECK_EXISTENCE(${MODULE_CAPTURE} "capture")
CHECK_EXISTENCE(${MODULE_INIT}    "init")

# run structmagic on struct definitions
GET_DIRECTORY_PROPERTY(INCDIRS INCLUDE_DIRECTORIES)
ADD_CUSTOM_COMMAND(
  OUTPUT ${MODULE_CSGLUE} ${MODULE_SERIAL} ${MODULE_CSCLASS} ${MODULE_TYPENAMES}
  COMMAND ${STRUCTMAGIC} ${MODULE} ${MODULE_DATADEF} ${MODULE_BINARY_DIR}
            ${INCDIRS}
  COMMAND mv ${MODULE_SOURCE_DIR}/gen-csglue.c ${MODULE_CSGLUE}
  COMMAND mv ${MODULE_SOURCE_DIR}/gen-serial.c ${MODULE_SERIAL}
  COMMAND mv ${MODULE_SOURCE_DIR}/gen-typenames.c ${MODULE_TYPENAMES}
  COMMAND mv ${MODULE_SOURCE_DIR}/gen-class.cs ${MODULE_CSCLASS}
  MAIN_DEPENDENCY ${MODULE_DATADEF}
  DEPENDS ${STRUCTMAGIC}
)
SET_SOURCE_FILES_PROPERTIES(${MODULE_CSGLUE} GENERATED)
SET_SOURCE_FILES_PROPERTIES(${MODULE_SERIAL} GENERATED)
SET_SOURCE_FILES_PROPERTIES(${MODULE_CSCLASS} GENERATED)
SET_SOURCE_FILES_PROPERTIES(${MODULE_TYPENAMES} GENERATED)
SET_SOURCE_FILES_PROPERTIES(${MODULE_LANGDEF} GENERATED)

# generate list of C files to compile
SET(MODULE_CFILES )
MACRO(ADD_CFILE f)
  SET(MODULE_CFILES ${MODULE_CFILES} ${f})
ENDMACRO(ADD_CFILE f)
ADD_CFILE(${MODULE_CAPTURE})
ADD_CFILE(${MODULE_DATADEF})
ADD_CFILE(${MODULE_INIT})
ADD_CFILE(${MODULE_SERIAL})
ADD_CFILE(${MODULE_TYPENAMES})
ADD_CFILE(${MODULE_LANGDEF})

SET(EXPORT_IN_C)
SET(EXPORT_IN_MONO)
IF(EXISTS ${MODULE_EXPORT_C})
  SET(EXLANG "EX_IMPL_C")
  SET(EXPORT_IN_C 1)
  MESSAGE("\texport: implemented in C")
ELSE(EXISTS ${MODULE_EXPORT_C})
  IF (EXISTS ${MODULE_EXPORT_CSHARP})
    SET(EXLANG "EX_IMPL_MONO")
    SET(EXPORT_IN_MONO 1)
    MESSAGE("\texport: implemented in mono")
  ELSE (EXISTS ${MODULE_EXPORT_CSHARP})
    SET(EXLANG "EX_IMPL_NONE")
    MESSAGE("\texport: not implemented")
  ENDIF (EXISTS ${MODULE_EXPORT_CSHARP})
ENDIF(EXISTS ${MODULE_EXPORT_C})

SET(QUERY_IN_C)
SET(QUERY_IN_MONO)
IF(EXISTS ${MODULE_QUERY_C})
  SET(QULANG "QU_IMPL_C")
  SET(QUERY_IN_C 1)
  MESSAGE("\tquery: implemented in C")
ELSE(EXISTS ${MODULE_QUERY_C})
  IF (EXISTS ${MODULE_QUERY_CSHARP})
    SET(QULANG "QU_IMPL_MONO")
    SET(QUERY_IN_MONO 1)
    MESSAGE("\tquery: implemented in mono")
  ELSE (EXISTS ${MODULE_QUERY_CSHARP})
    SET(QULANG "QU_IMPL_NONE")
    MESSAGE("\tquery: not implemented")
  ENDIF (EXISTS ${MODULE_QUERY_CSHARP})
ENDIF(EXISTS ${MODULE_QUERY_C})

WRITE_FILE(${MODULE_LANGDEF} "#include \"como.h\"
ex_impl_t ex_impl = ${EXLANG};
qu_impl_t qu_impl = ${QULANG};
")
IF(EXPORT_IN_C)
  CHECK_EXISTENCE(${MODULE_EXPORT_C} "export")
  ADD_CFILE(${MODULE_EXPORT_C})
ENDIF(EXPORT_IN_C)

IF(QUERY_IN_C)
  CHECK_EXISTENCE(${MODULE_QUERY_C} "query")
  ADD_CFILE(${MODULE_QUERY_C})
ENDIF(QUERY_IN_C)

IF(EXPORT_IN_MONO OR QUERY_IN_MONO)
  IF (NOT MONO_FOUND)
    MESSAGE(FATAL_ERROR "module ${MODULE} requires mono")
  ENDIF(NOT MONO_FOUND)
  ADD_CFILE(${MODULE_CSGLUE})
ENDIF(EXPORT_IN_MONO OR QUERY_IN_MONO)

# add cflags to C files
SET_SOURCE_FILES_PROPERTIES(${MODULE_CFILES}
    PROPERTIES COMPILE_FLAGS ${MODULE_CFLAGS})

# Compile C code
ADD_LIBRARY(${MODULE} SHARED ${MODULE_CFILES})
TARGET_LINK_LIBRARIES(${MODULE} @ABS_INST_LIBDIR@/libcomomdl.a)

SET_TARGET_PROPERTIES(${MODULE} PROPERTIES PREFIX "")
IF(APPLE)
SET_TARGET_PROPERTIES(${MODULE}
    PROPERTIES LINK_FLAGS "-undefined dynamic_lookup")
ENDIF(APPLE)

INSTALL(FILES ${MODULE_SO} DESTINATION @ABS_INST_LIBDIR@)

# Compile C# code
IF(EXISTS ${MODULE_EXPORT_CSHARP})
  CHECK_EXISTENCE(${MODULE_EXPORT_CSHARP} "export") # just for the output

  # Custom target that must be always built
  ADD_CUSTOM_TARGET("${MODULE}-Csharp" ALL DEPENDS ${MODULE_DLL})
  ADD_CUSTOM_COMMAND(
      OUTPUT ${MODULE_DLL}
      COMMAND ${MONO_MCS} -out:${MODULE_DLL} -target:library
          -lib:@ABS_INST_LIBDIR@ -r:como.dll ${MODULE_EXPORT_CSHARP}
          ${MODULE_QUERY_CSHARP} ${MODULE_CSCLASS}
      MAIN_DEPENDENCY ${MODULE_EXPORT_CSHARP}
      DEPENDS ${MODULE_QUERY_CSHARP}
      DEPENDS ${MODULE_CSCLASS}
  )

  INSTALL(FILES ${MODULE_DLL} DESTINATION @ABS_INST_LIBDIR@)

ENDIF(EXISTS ${MODULE_EXPORT_CSHARP})

