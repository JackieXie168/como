INCLUDE_DIRECTORIES(${COMO_SOURCE_DIR}/include)

SET(MODULES
#  apps
#  assoc
#  dhcp
#  ethtypes
#  ewma
#  flowcount
#  frames
#  ipssi
#  macssi
#  nfexlist
#  pattern-search
#  protocol
#  ssid
#  topaddr
#  tophwaddr
#  topports
#  trace
  trafficCC
  topaddrCC
  trafficCCS
#  hwtm
#  tuple
#  unknown-ports
)

#IF(FTLIB_FOUND)
#  SET(MODULES
#    ${MODULES}
#    netflow-anon
#  )
#ENDIF(FTLIB_FOUND)

#
# Unused variables in modules are ok. If we are doing a debug
# build, we have -Wall -Werror, so we add -Wno-unused.
#
IF(ENABLE_DEBUG)
  ADD_DEFINITIONS(-Wno-unused)
ENDIF(ENABLE_DEBUG)

#
# If we have mono, add the appropirate CFLAGS.
#
IF (MONO_FOUND)
  ADD_DEFINITIONS(${MONO_CFLAGS})
ENDIF(MONO_FOUND)

#
# Wipe structmagic-specific keywords from C source files
#
ADD_DEFINITIONS("-Dcomo_config=\"\" -Dcomo_tuple=\"\" -Dcomo_record=\"\"")

#
# Create appropriate targets for each module
#
MESSAGE(STATUS "Inferring module dependencies")
FOREACH (MODULE ${MODULES})
  # source files
  SET(MODULE_SOURCE_DIR     ${COMO_SOURCE_DIR}/modules/${MODULE})
  SET(MODULE_DATADEF        ${MODULE_SOURCE_DIR}/data.h)
  SET(MODULE_INIT           ${MODULE_SOURCE_DIR}/init.c)
  SET(MODULE_CAPTURE        ${MODULE_SOURCE_DIR}/capture.c)
  SET(MODULE_EXPORT_C       ${MODULE_SOURCE_DIR}/export.c)
  SET(MODULE_EXPORT_CSHARP  ${MODULE_SOURCE_DIR}/export.cs)
  SET(MODULE_QUERY_C        ${MODULE_SOURCE_DIR}/query.c)
  SET(MODULE_QUERY_CSHARP   ${MODULE_SOURCE_DIR}/query.cs)

  # build dirs
  SET(MODULE_BINARY_DIR     ${COMO_BINARY_DIR}/modules/${MODULE})
  SET(MODULE_DLL            ${COMO_BINARY_DIR}/modules/${MODULE}.dll)
  
  # files generated by structmagic
  SET(MODULE_SERIAL         ${MODULE_BINARY_DIR}/gen-serial.c)
  SET(MODULE_CSGLUE         ${MODULE_BINARY_DIR}/gen-csglue.c)
  SET(MODULE_TYPENAMES      ${MODULE_BINARY_DIR}/gen-typenames.c)
  SET(MODULE_CSCLASS        ${MODULE_BINARY_DIR}/gen-class.cs)

  SET(MODULE_LANGDEF        ${MODULE_BINARY_DIR}/langdef.c)
  # location of structmagic
  SET(STRUCTMAGIC ${COMO_BINARY_DIR}/misc/structmagic)
  # specific cflags to compile the module
  SET(MODULE_CFLAGS "-I${MODULE_SOURCE_DIR}")

  # macro to check a file exists & print a notice
  MACRO(CHECK_EXISTANCE _file _what)
    IF(NOT EXISTS ${_file})
      MESSAGE(FATAL_ERROR "module ${MODULE} is missing ${_file}")
    ENDIF(NOT EXISTS ${_file})
  MESSAGE("\t\t${_what}: file ${_file}")
  ENDMACRO(CHECK_EXISTANCE)

  # check for required files
  MESSAGE("\t. ${MODULE}")
  CHECK_EXISTANCE(${MODULE_DATADEF} "datadef")
  CHECK_EXISTANCE(${MODULE_CAPTURE} "capture")
  CHECK_EXISTANCE(${MODULE_INIT}    "init")

  MAKE_DIRECTORY(${MODULE_BINARY_DIR})

  # run structmagic on struct definitions
  GET_DIRECTORY_PROPERTY(INCDIRS INCLUDE_DIRECTORIES)
  ADD_CUSTOM_COMMAND(
    OUTPUT ${MODULE_CSGLUE} ${MODULE_SERIAL} ${MODULE_CSCLASS} ${MODULE_TYPENAMES}
    COMMAND ${STRUCTMAGIC} ${MODULE} ${MODULE_DATADEF} ${INCDIRS}
    COMMAND mv ${MODULE_SOURCE_DIR}/gen-csglue.c ${MODULE_CSGLUE}
    COMMAND mv ${MODULE_SOURCE_DIR}/gen-serial.c ${MODULE_SERIAL}
    COMMAND mv ${MODULE_SOURCE_DIR}/gen-typenames.c ${MODULE_TYPENAMES}
    COMMAND mv ${MODULE_SOURCE_DIR}/gen-class.cs ${MODULE_CSCLASS}
    MAIN_DEPENDENCY ${MODULE_DATADEF}
    DEPENDS ${STRUCTMAGIC}
  )
  SET_SOURCE_FILES_PROPERTIES(${MODULE_CSGLUE} GENERATED)
  SET_SOURCE_FILES_PROPERTIES(${MODULE_SERIAL} GENERATED)
  SET_SOURCE_FILES_PROPERTIES(${MODULE_CSCLASS} GENERATED)
  SET_SOURCE_FILES_PROPERTIES(${MODULE_TYPENAMES} GENERATED)
  SET_SOURCE_FILES_PROPERTIES(${MODULE_LANGDEF} GENERATED)

  # generate list of C files to compile
  SET(MODULE_CFILES )
  MACRO(ADD_CFILE f)
    SET(MODULE_CFILES ${MODULE_CFILES} ${f})
  ENDMACRO(ADD_CFILE f)
  ADD_CFILE(${MODULE_CAPTURE})
  ADD_CFILE(${MODULE_DATADEF})
  ADD_CFILE(${MODULE_INIT})
  ADD_CFILE(${MODULE_SERIAL})
  ADD_CFILE(${MODULE_TYPENAMES})
  ADD_CFILE(${MODULE_LANGDEF})

  SET(EXPORT_IN_C)
  SET(EXPORT_IN_MONO)
  IF(EXISTS ${MODULE_EXPORT_C})
    SET(EXLANG "EX_IMPL_C")
    SET(EXPORT_IN_C 1)
    MESSAGE("\t\texport: implemented in C")
  ELSE(EXISTS ${MODULE_EXPORT_C})
    IF (EXISTS ${MODULE_EXPORT_CSHARP})
      SET(EXLANG "EX_IMPL_MONO")
      SET(EXPORT_IN_MONO 1)
      MESSAGE("\t\texport: implemented in MONO")
    ELSE (EXISTS ${MODULE_EXPORT_CSHARP})
      SET(EXLANG "EX_IMPL_NONE")
      MESSAGE("\t\texport: not implemented")
    ENDIF (EXISTS ${MODULE_EXPORT_CSHARP})
  ENDIF(EXISTS ${MODULE_EXPORT_C})

  SET(QUERY_IN_C)
  SET(QUERY_IN_MONO)
  IF(EXISTS ${MODULE_QUERY_C})
    SET(QULANG "QU_IMPL_C")
    SET(QUERY_IN_C 1)
    MESSAGE("\t\tquery: implemented in C")
  ELSE(EXISTS ${MODULE_QUERY_C})
    IF (EXISTS ${MODULE_QUERY_CSHARP})
      SET(QULANG "QU_IMPL_MONO")
      SET(QUERY_IN_MONO 1)
      MESSAGE("\t\tquery: implemented in MONO")
    ELSE (EXISTS ${MODULE_QUERY_CSHARP})
      SET(QULANG "QU_IMPL_NONE")
      MESSAGE("\t\tquery: not implemented")
    ENDIF (EXISTS ${MODULE_QUERY_CSHARP})
  ENDIF(EXISTS ${MODULE_QUERY_C})

  WRITE_FILE(${MODULE_LANGDEF} "#include \"como.h\"
ex_impl_t ex_impl = ${EXLANG};
qu_impl_t qu_impl = ${QULANG};
")

  IF(EXPORT_IN_C)
    CHECK_EXISTANCE(${MODULE_EXPORT_C} "export")
    ADD_CFILE(${MODULE_EXPORT_C})
  ENDIF(EXPORT_IN_C)

  IF(QUERY_IN_C)
    CHECK_EXISTANCE(${MODULE_QUERY_C} "query")
    ADD_CFILE(${MODULE_QUERY_C})
  ENDIF(QUERY_IN_C)

  IF(EXPORT_IN_MONO OR QUERY_IN_MONO)
    IF (NOT MONO_FOUND)
      MESSAGE(FATAL_ERROR "module ${MODULE} requires mono")
    ENDIF(NOT MONO_FOUND)
    ADD_CFILE(${MODULE_CSGLUE})
  ENDIF(EXPORT_IN_MONO OR QUERY_IN_MONO)

  # add cflags to C files
  SET_SOURCE_FILES_PROPERTIES(${MODULE_CFILES}
      PROPERTIES COMPILE_FLAGS ${MODULE_CFLAGS})

  # Compile C code
  ADD_LIBRARY(${MODULE} SHARED ${MODULE_CFILES})
  SET_TARGET_PROPERTIES(${MODULE} PROPERTIES PREFIX "")
  IF(APPLE)
  SET_TARGET_PROPERTIES(${MODULE}
      PROPERTIES LINK_FLAGS "-undefined dynamic_lookup")
  ENDIF(APPLE)

  # Compile C# code
  IF(EXISTS ${MODULE_EXPORT_CSHARP})
    CHECK_EXISTANCE(${MODULE_EXPORT_CSHARP} "export") # just for the output

    # Custom target that must be always built
    ADD_CUSTOM_TARGET("${MODULE}-Csharp" ALL DEPENDS ${MODULE_DLL})
    ADD_CUSTOM_COMMAND(
        OUTPUT ${MODULE_DLL}
        COMMAND ${MONO_MCS} -out:${MODULE_DLL} -target:library
            -lib:${COMO_BINARY_DIR}/mono -r:como.dll ${MODULE_EXPORT_CSHARP}
            ${MODULE_QUERY_CSHARP} ${MODULE_CSCLASS}
        MAIN_DEPENDENCY ${MODULE_EXPORT_CSHARP}
        DEPENDS ${MODULE_QUERY_CSHARP}
        DEPENDS ${MODULE_CSCLASS} ${COMO_BINARY_DIR}/mono/como.dll
    )
  ENDIF(EXISTS ${MODULE_EXPORT_CSHARP})
ENDFOREACH (MODULE)

#IF(ENABLE_SHARED_MODULES)
#  FOREACH(module ${MODULES})
#    ADD_LIBRARY(${module} SHARED ${module}.c)
#    # Get rid of the 'lib' prefix for modules
#    SET_TARGET_PROPERTIES(${module}
#      PROPERTIES
#      PREFIX ""
#    )
#    IF(APPLE)
#	SET_TARGET_PROPERTIES(${module}
#	PROPERTIES
#	LINK_FLAGS "-undefined dynamic_lookup")
#    ENDIF(APPLE)
#    INSTALL_TARGETS(${INST_LIBDIR} ${module})
#  ENDFOREACH(module)
#ELSE(ENABLE_SHARED_MODULES)
#  #
#  # Write modules-list.h
#  #
#  SET(MODULES_LIST ${COMO_BINARY_DIR}/include/modules-list.h)
#  WRITE_FILE(${MODULES_LIST}
#"/* generated file, do not edit */
#
#typedef struct builtin_module {
#    const char *	name;
#    module_cb_t *	cb;
#} builtin_module_t;
#
#")
#
#  FOREACH(module ${MODULES})
#    # Replace - with _ in the C module name
#    STRING(REPLACE "-" "_" _cmodule ${module})
#    WRITE_FILE(${MODULES_LIST}
#"extern module_cb_t g_${_cmodule}_module;" APPEND)
#  ENDFOREACH(module)
#
#  WRITE_FILE(${MODULES_LIST}
#"builtin_module_t g_como_builtin_modules[] = {" APPEND)
#
#  FOREACH(module ${MODULES})
#    # Replace - with _ in the C module name
#    STRING(REPLACE "-" "_" _cmodule ${module})
#    WRITE_FILE(${MODULES_LIST}
#"    { \"${module}\", &g_${_cmodule}_module }," APPEND)
#  ENDFOREACH(module)
#
#  WRITE_FILE(${MODULES_LIST}
#"    { NULL, NULL } };" APPEND)
#
#  ADD_LIBRARY(modules STATIC ${MODULES})
#
#ENDIF(ENABLE_SHARED_MODULES)
