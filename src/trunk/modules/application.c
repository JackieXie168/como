/*
 * Copyright (c) 2004 Intel Corporation
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id$
 */

/*
 * Application module
 *
 * This module computes the number of packets and bytes per application.
 * Output: packets/bytes per application over 1s intervals
 *
 * It supports only TCP packets. 
 * 
 * This implementation requires that min-flush = max-flush and equal to 
 * the desired granularity of the measurement. 
 * 
 * Optional arguments for init():  
 * 
 * .  "granularity = 0.4"
 * 
 *    specifies the measurement interval. this is used for the output 
 *    description for a packet trace generated by this module. 
 *    the granularity must be equal to min-flush and max-flush. 
 * 
 * No optional arguments for print(). 
 *
 * 
 */

#include <stdio.h>
#include <errno.h>
#include <time.h>
#include <math.h>

#include "como.h"
#include "module.h"

/*
 * List of known applications
 * Application code means also application priority
 */
#define WEB		0x00
#define TERMINAL	0x01	/* ssh, telnet, etc. */
#define EMAIL		0x03	/* email, news, etc. */
#define NETWORKDATA	0x07	/* dns, ntp, netbios, nfs, ftp, etc. */
#define STREAM		0x0f
#define GAMES		0x1f
#define SHARING		0x3f
#define UNKNOWN		0x7f    

#define APPLICATIONS       8 
#define APPCODE(x)	   ((((uint) 1) << x) - 1) 

#define FLOWDESC    struct _app_stat
FLOWDESC {
    timestamp_t ts;
    uint64_t bytes[UNKNOWN + 1];
    uint64_t pkts[UNKNOWN + 1];
};

/* 
 * this is the data record that we store on disk
 */
typedef struct {
    uint32_t ts;
    uint64_t bytes[APPLICATIONS];
    uint64_t pkts[APPLICATIONS];
} app_t;


/* 
 * packet description and templates for the 
 * replay() callback or to know if we can process
 * the packets from given sniffer
 */
static pktdesc_t indesc, outdesc;
static pkt_t * pkt_template; 


/* 
 * static variable for the modules. 
 * XXX we should get rid of these to force callbacks to be closures. 
 */
static timestamp_t meas_ivl = TIME2TS(1,0); 	/* measurement granularity */
static uint8_t port2app[65536];			/* mapping port number to app */

static int
init(__unused void *mem, __unused size_t msize, char *args[])
{
    int i;

    memset(port2app, UNKNOWN, sizeof(port2app));

    /* initialize the port-to-application mapping array */
    port2app[80]    = WEB;
    port2app[443]   = WEB;
    port2app[8080]  = WEB;
    port2app[3128]  = WEB;             // SQUID
    port2app[3130]  = WEB;             // SQUID
    port2app[9090]  = WEB;             // AUTOPROXY 

    port2app[6688]  = SHARING;
    port2app[6697]  = SHARING;
    port2app[6699]  = SHARING;
    port2app[4329]  = SHARING;
    port2app[4444]  = SHARING;
    port2app[5555]  = SHARING;
    port2app[6666]  = SHARING;
    port2app[7777]  = SHARING;
    port2app[6346]  = SHARING;
    port2app[1214]  = SHARING;
    for (i = 4000; i <= 4999; i++) {
        port2app[i] = SHARING;
    }

    port2app[22]    = TERMINAL;         // SSH
    port2app[23]    = TERMINAL;         // TELNET
    port2app[992]   = TERMINAL;         // TELNET

    port2app[25]    = EMAIL;             //SMTP
    port2app[465]   = EMAIL;             //SMTPS
    port2app[109]   = EMAIL;             //POP
    port2app[110]   = EMAIL;             //POP
    port2app[995]   = EMAIL;             //POP
    port2app[143]   = EMAIL;             //IMAP
    port2app[220]   = EMAIL;             //IMAP
    port2app[993]   = EMAIL;             //IMAP
    port2app[119]   = EMAIL;             //NNTP
    port2app[563]   = EMAIL;             //NNTP

    port2app[20]    = NETWORKDATA;	// FTP
    port2app[21]    = NETWORKDATA;	// FTP
    port2app[989]   = NETWORKDATA;	// FTP
    port2app[990]   = NETWORKDATA;	// FTP
    port2app[53]    = NETWORKDATA;      //DNS
    port2app[161]   = NETWORKDATA;          //SNMP
    port2app[162]   = NETWORKDATA;          //SNMP
    port2app[123]   = NETWORKDATA;          //NTP
    port2app[873]   = NETWORKDATA;    	//RSYNC
    port2app[1110]  = NETWORKDATA;     //NFS
    port2app[2049]  = NETWORKDATA;     //NFS
    port2app[135]   = NETWORKDATA;        //NETBIOS
    port2app[137]   = NETWORKDATA;        //NETBIOS
    port2app[138]   = NETWORKDATA;        //NETBIOS
    port2app[139]   = NETWORKDATA;        //NETBIOS
    port2app[445]   = NETWORKDATA;        //NETBIOS
    port2app[568]   = NETWORKDATA;        //NETBIOS
    port2app[569]   = NETWORKDATA;        //NETBIOS
    port2app[1512]  = NETWORKDATA;        //NETBIOS
    port2app[311]   = NETWORKDATA;        //APPLETALK
    port2app[387]   = NETWORKDATA;        //APPLETALK
    port2app[548]   = NETWORKDATA;        //APPLETALK

    port2app[4662]  = SHARING;              //E_DONKEY
    port2app[7070]  = SHARING;              //E_DONKEY
    port2app[1214]  = SHARING;              //FASTTRACK
    port2app[6346]  = SHARING;              //GNUTELLA
    port2app[412]   = SHARING;              //DIRECT_CONNECT
    port2app[5000]  = SHARING;              //IMESH_CONTROL
    port2app[4329]  = SHARING;              //IMESH_DATA
    port2app[6574]  = SHARING;              //ROMNET
    port2app[8311]  = SHARING;              //SCOUR_EX
    port2app[5500]  = SHARING;              //HOTLINE
    port2app[5501]  = SHARING;              //HOTLINE
    
    
    /* 
     * process input arguments 
     */
    if (args != NULL) { 
	for (i = 0; args[i]; i++) { 
	    if (strstr(args[i], "granularity")) {
		char * len; 
		double value; 
		uint32_t sec, usec; 

		len = index(args[i], '='); 
		len++; 	/* skip '=' */

		value = strtod(len, NULL); 
		sec = (uint32_t) floor(value);
		usec = (uint32_t) floor((value - floor(value)) * 1000000); 
		meas_ivl = TIME2TS(sec, usec); 
	    } 
	}
    } 
	 
    /* 
     * our input stream needs to contain the port numbers and 
     * a packet length. for the timestamp, we use a default value of 
     * one second or whatever we receive from configuration 
     */ 
    bzero(&indesc, sizeof(pktdesc_t));
    indesc.ts = meas_ivl; 
    indesc.ih.proto = 0xff;
    N16(indesc.ih.len) = 0xffff;
    N16(indesc.tcph.src_port) = 0xffff;
    N16(indesc.tcph.dst_port) = 0xffff;
    
    bzero(&outdesc, sizeof(pktdesc_t));
    outdesc.ts = meas_ivl;
    outdesc.flags = COMO_AVG_PKTLEN; 
    N16(outdesc.ih.len) = 0xffff;
    
    pkt_template = safe_calloc(1, sizeof(struct _como_iphdr) + sizeof(pkt_t)); 
    pkt_template->caplen = htonl(sizeof(struct _como_iphdr)); 
    pkt_template->l2type = COMO_L2_NONE; 
    pkt_template->l3type = ETHERTYPE_IP;
    pkt_template->layer3ofs = 0; 
    pkt_template->layer4ofs = sizeof(struct _como_iphdr); 
    IPP(pkt_template, vhl) = 0x45; 
    IPP(pkt_template, proto) = IPPROTO_TCP; 

    return 0;
}


static int
update(pkt_t *pkt, void *fh, int isnew)
{
    FLOWDESC *x = F(fh);
    int app; 

    if (isnew) {
	x->ts = TS2SEC(pkt->ts);
        bzero(x->bytes, sizeof(x->bytes)); 
        bzero(x->pkts, sizeof(x->pkts)); 
    }
    
    app = port2app[H16(TCP(src_port))] & port2app[H16(TCP(dst_port))];
    x->bytes[app] += H16(IP(len));
    x->pkts[app]++;

    return 0;
}


static ssize_t
store(void *fh, char *buf, size_t len)
{
    FLOWDESC *x = F(fh);
    int i;
    
    if (len < sizeof(app_t))
        return -1;

    PUTH32(buf, x->ts); 
    for (i = 0; i < APPLICATIONS; i++) 
	PUTH64(buf, x->bytes[APPCODE(i)]);
    for (i = 0; i < APPLICATIONS; i++) 
	PUTH64(buf, x->pkts[APPCODE(i)]);
    return sizeof(app_t);
}

static size_t
load(char * buf, size_t len, timestamp_t * ts)
{
    if (len < sizeof(app_t)) {
        ts = 0;
        return 0; 
    }

    *ts = TIME2TS(ntohl(((app_t *)buf)->ts), 0);
    return sizeof(app_t);
}

#define PRETTYHDR               \
    "Date                     " \
    "  Web (bytes/pkts)"	\
    "          Terminal"	\
    "             Email" 	\
    "           Network"	\
    "            Stream"	\
    "             Games"	\
    "               P2P"	\
    "           Unknown\n"

static char *
print(char *buf, size_t *len, char * const args[])
{
    static char s[2048];
    app_t *x; 
    time_t ts; 
    int i; 

    if (buf == NULL && args != NULL) { 
	/* we support one format only. print the header */
	*len = sprintf(s, PRETTYHDR);  
	return s; 
    } 

    if (buf == NULL && args == NULL) {
	/* no footer */
	*len = 0; 
	return s; 
    } 
	
    x = (app_t *) buf; 
    ts = (time_t) ntohl(x->ts);

    *len = sprintf(s, "%.24s ", asctime(localtime(&ts))); 
    for (i = 0; i < APPLICATIONS; i++) { 
	*len += sprintf(s + *len, "%8llu %8llu ", 
	    NTOHLL(x->bytes[i]), NTOHLL(x->pkts[i]));
    } 
    *len += sprintf(s + *len, "\n"); 
    return s;
};

static int
replay(char *buf, char *out, size_t * len)
{
    static int npkts = 0; 
    size_t out_len; 
    
    if (*len < NTOH_STDPKT_LEN(pkt_template))
        return -1;
    
    /* 
     * if there are no pending packets, this must be a new record. 
     * build the template accordingly. 
     */
    if (npkts == 0) { 
	app_t * app = (app_t *) buf;
	timestamp_t ts; 
	int nbytes; 
	int i; 

	nbytes = 0; 
	for (i = 0; i < APPLICATIONS; i++) { 
	    npkts += NTOHLL(app->pkts[i]); 
	    nbytes += NTOHLL(app->bytes[i]); 
	} 
	N16(IPP(pkt_template, len)) = htons((uint16_t) (nbytes / npkts)); 
	ts = TIME2TS(ntohl(app->ts), 0);
	pkt_template->ts = HTONLL(ts); 
    }
    
    for (out_len = 0; out_len < *len && npkts > 0; npkts--) { 
	bcopy(pkt_template, out + out_len, NTOH_STDPKT_LEN(pkt_template)); 
	out_len += NTOH_STDPKT_LEN(pkt_template);
    } 
    
    *len = out_len; 
    return npkts; 
}


callbacks_t callbacks = {
    ca_recordsize: sizeof(FLOWDESC),
    ex_recordsize: 0, 
    indesc: &indesc,
    outdesc: &outdesc,
    init: init,
    check: NULL,
    hash: NULL,
    match: NULL,
    update: update,
    ematch: NULL,
    export: NULL,
    compare: NULL,
    action: NULL,
    store: store,
    load: load,
    print: print,
    replay: replay 
};

